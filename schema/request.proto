syntax = "proto3";


package lldbprotobuf;
import "model.proto";



// 创建 Target 请求
// 语义对应：SBDebugger::CreateTarget(...), SBTarget
message CreateTargetRequest {
  // 可执行文件路径（若为空可仅创建 target 以便 later attach/remote）
  string file_path = 1;

  // 可选目标三元组（例如 "x86_64-unknown-linux-gnu"）
  string target_triple = 2;

  // 可扩展选项（例如 {"platform":"remote","arch":"arm64"}）
  map<string, string> options = 3;
}

// 表达式求值请求（可在特定 frame 上求值）
// 对应 LLDB 的 SBFrame::EvaluateExpression / SBTarget::EvaluateExpression 与 SBExpressionOptions
message EvaluateRequest {
  // 表达式文本，例如 "myVar + 1" 或 "this->field"
  string expression = 1;
  Id thread_id = 4;
  // 可选：在特定栈帧上下文求值
  uint32 frame_index = 2;


  // 是否禁用 summary provider（格式化摘要）
  bool disable_summaries = 3;
}


/**
 * 暂停执行请求
 *
 * 立即中断所有线程的执行（类似发送 SIGINT）。
 */
message SuspendRequest {}

/**
 * 单步进入请求
 *
 * 执行一行源代码或一条机器指令。
 * 如果遇到函数调用，则进入函数内部。
 */
message StepIntoRequest {
  // 目标线程 ID
  Id thread_id = 1;

  // 是否按机器指令单步（false 则按源代码行）
  bool step_by_instruction = 2;
}

/**
 * 单步跳过请求
 *
 * 执行一行源代码或一条机器指令。
 * 遇到函数调用时不进入，直接执行完整个调用。
 */
message StepOverRequest {
  // 目标线程 ID
  Id thread_id = 1;

  // 是否按机器指令单步
  bool step_by_instruction = 2;
}

/**
 * 单步跳出请求
 *
 * 执行当前函数的剩余部分，直到返回到调用者。
 */
message StepOutRequest {
  // 目标线程 ID
  Id thread_id = 1;
}


message ContinueRequest {Id thread = 1;}
// 读取内存：对应 SBProcess::ReadMemory
message ReadMemoryRequest {


  // 要读取的起始地址（虚拟地址）
  uint64 address = 2;

  // 要读取的字节数
  uint32 size = 3;
}

// 写入内存：对应 SBProcess::WriteMemory
message WriteMemoryRequest {

  // 要写入的起始地址（虚拟地址）
  uint64 address = 2;

  // 要写入的数据（二进制数据，base64编码或直接二进制）
  string data = 3;
}

/**
 * 反汇编请求
 *
 * 对指定地址范围的机器码进行反汇编，返回汇编指令。
 */
message DisassembleRequest {
  // 反汇编的起始地址（虚拟地址）
  uint64 start_address = 1;

  // 反汇编的结束地址（虚拟地址）
  uint64 end_address = 2;

  // 反汇编的字节数（如果设置了 count，则优先使用 count 而不是 end_address）
  uint32 count = 3;

  // 目标线程 ID（可选，用于获取特定线程的上下文）
  Id thread_id = 4;

  // 反汇编选项
  DisassembleOptions options = 5;
}


message VariablesRequest {
  // 目标线程 ID
  Id thread_id = 1;

  // 栈帧索引
  uint32 frame_index = 2;

  // 是否包含参数
  bool include_arguments = 3;

  // 是否包含本地变量
  bool include_locals = 4;

  // 是否包含静态变量
  bool include_statics = 5;

  // 是否只包含当前作用域内的变量
  bool in_scope_only = 6;

  // 是否包含运行时支持的变量（如 this 指针、返回值等）
  bool include_runtime_support_values = 7;

  // 动态值获取选项
  DynamicValueType use_dynamic = 8;

  // 是否包含已识别的参数（类型推断的参数）
  bool include_recognized_arguments = 9;

  // 是否获取寄存器
  bool include_registers = 10;
}

// 请求变量值
message GetValueRequest {
  // 变量 ID
  Id variable_id = 1;


  // 字符串的最大长度（防止获取过长的字符串）
  uint32 max_string_length = 7;
}

// 设置变量值请求
// 对应 LLDB 的 SBValue::SetValueFromCString 或 SBFrame::SetValueForVariablePath
message SetVariableValueRequest {
  // 变量 ID（要修改的变量）
  Id variable_id = 1;

  // 新的值（字符串形式）
  string value = 2;

 
}

/**
 * 获取变量的子变量请求
 *
 * 获取复合类型（数组、结构体、类）的成员变量或子元素。
 */
message VariablesChildrenRequest {
  // 父变量的 ID
  Id variable_id = 1;




  // 表达式（可选，用于动态子元素）
  string expression = 4;

  // 起始偏移量
  uint32 offset = 5;

  // 获取数量
  uint32 count = 6;

  // 子变量获取的最大深度（防止无限递归）
  uint32 max_depth = 7;

  // 数组/容器的最大子元素数量（防止获取过多元素）
  uint32 max_children = 8;
}
message LineBreakpoint {
  string file = 1;
  uint32 line = 2;
  // 是否忽略源文件哈希校验（默认 false）
  bool ignore_source_hash = 9;
}

message AddressBreakpoint {uint64 address = 1;}
message FunctionBreakpoint {string function_name = 1; string mangled_name = 2;}

message SymbolBreakpoint {
  // 符号名称或模式，例如 "main" 或 "MyClass::*"
  string  pattern = 4;

  // 是否按正则表达式匹配
  bool is_regex = 7;

  // 可选：限定模块名以缩小匹配范围
  string module = 5;
}

// Watchpoint（内存读/写监视），对应 SBBreakpoint / SBWatchpoint 接口
message WatchBreakpoint {
  // 要观察的变量值 ID（通过表达式求值获得）
  Id value_id = 1;
  // 是否解析内存位置到源代码
  bool resolve_location = 2;

  // 字节长度（平台相关，部分平台要求对齐）
  uint64 size = 3;

  // 在读时触发
  bool watch_read = 4;

  // 在写时触发
  bool watch_write = 5;
}


message RemoveBreakpointRequest {Id breakpoint_id = 1;}
// 添加断点请求
message AddBreakpointRequest {
  // 限定线程 Id（可选，0 表示所有线程）
  Id thread_id = 1;

  // 断点规格（多种形式：行、地址、函数、watch、符号）
  oneof spec {
    LineBreakpoint line = 10;
    AddressBreakpoint address = 11;
    FunctionBreakpoint function = 12;
    WatchBreakpoint watchpoint = 13;
    SymbolBreakpoint symbol = 14;
  }

  // 条件表达式
  string condition = 20;

  // 是否启用断点（默认 true）
  bool enabled = 21;

  // 忽略计数（在命中前忽略 n 次）
  uint32 ignore_count = 22;
}
// 请求栈帧（分页）
message FramesRequest {
  // 线程 Id
  Id thread_id = 1;

  // 分页起始帧索引（0 表示最顶部帧）
  uint32 start_index = 2;

  // 请求返回的帧数量
  uint32 count = 3;

  // 是否只获取第一个有效的源码行，跳过无调试信息的栈帧
  bool first_valid_source_only = 4;
}
// 请求线程列表
message ThreadsRequest {

}

// 启动请求（对应 SBLaunchInfo + SBTarget::Launch / SBTarget::LaunchSimple）
message LaunchRequest {

  ProcessLaunchInfo  launch_info = 1;
  // 命令行参数数组（argv），通常不包含可执行名本身

  // 控制台模式（Parent / External / PTY）
  ConsoleMode console_mode = 8;
}

/**
 * 终止进程请求
 *
 * 强制终止被调试进程。
 */
message TerminateRequest {}

/**
 * 分离调试器请求
 *
 * 分离调试器但让被调试进程继续运行。
 */
message DetachRequest {}

/**
 * 退出调试器请求
 *
 * 完全退出调试会话，清理所有资源。
 */
message ExitRequest {}
// 附加请求（对应 SBTarget::AttachToProcessWithID / SBTarget::Attach）
message AttachRequest {
  // 可选：指定 target（某些后端允许多 target 管理）
  Id process_id = 1;

  // 系统进程 ID（PID）
  uint64 pid = 2;

  // 可扩展选项（例如 {"wait_for":"attach"}）
  map<string, string> options = 3;
}
/*
 * 说明与实现提示：
 * - 后端实现需维护 Id -> SB* 对象的映射表（例如 map<uint64, SBBreakpoint*> / SBProcess* / SBThread*）。
 * - 对于可能返回大量项的接口（线程、栈帧、变量等），应支持分页与延迟加载。
 * - 在将协议方法映射到 LLDB API 时，请参考对应注释中列出的 SB* 接口名称（例如 SBLaunchInfo / SBTarget::Launch / SBProcess::ReadMemory 等）。
 * - 错误与状态应尽量在 Status.message 中提供可操作的信息，后端可以将 SBError::GetCString() 内容放入 message 字段。
 */
/* =========================================================================
 * 顶层请求（客户端 → 调试后端）
 *
 * 每条消息必须带 hash，以便前后端匹配请求和响应。
 * hash 是由 IDE 生成的唯一标识符，调试器在响应中需要返回相同的 hash。
 * =========================================================================
 */
message Request {
  // 请求的唯一哈希值，用于匹配请求和响应
  // IDE 在发送请求时生成，调试器在对应响应中必须返回相同的 hash
  uint64 hash = 1;

  oneof request {
    CreateTargetRequest create_target = 2;
    LaunchRequest launch = 3;
    AttachRequest attach = 4;

    ThreadsRequest threads = 5;
    FramesRequest frames = 6;
    VariablesRequest variables = 10;

    AddBreakpointRequest add_breakpoint = 7;
    RemoveBreakpointRequest remove_breakpoint = 8;

    GetValueRequest get_value = 22;
    SetVariableValueRequest set_variable_value = 24;
    VariablesChildrenRequest get_variables_children = 23;

    EvaluateRequest evaluate = 11;

    ReadMemoryRequest read_memory = 13;
    WriteMemoryRequest write_memory = 14;
    DisassembleRequest disassemble = 15;

    ContinueRequest continue = 16;
    SuspendRequest suspend = 17;
    StepIntoRequest step_into = 18;
    StepOverRequest step_over =  19;
    StepOutRequest step_out = 26;
    TerminateRequest terminate = 20;
    DetachRequest detach = 21;
    ExitRequest exit = 27;
  }
}
